
   ----------------------------
   -- Knuth-Bendix procedure --
   ----------------------------

-- Matrix operations (SL2)

commutator :: Integer -> [[Integer]] -> [[Integer]] -> [[Integer]]
commutator pq a b =
  let mm = matrix_mult pq in
  let mi = matrix_inverse pq in
    a `mm` b `mm` (mi a) `mm` (mi b)

and_operation :: Integer -> ([[Integer]],[[Integer]]) -> ([[Integer]],[[Integer]]) -> IO [[Integer]] -> IO ([[Integer]],[[Integer]])
and_operation pq (a1,a2) (b1,b2) sample =
  sample >>= \z -> 
  let mm = matrix_mult pq in
  let mi = matrix_inverse pq in
  return (commutator pq (z `mm` a1 `mm` (mi z)) b1,
          commutator pq (z `mm` a2 `mm` (mi z)) b2)
  
not_operation pq (a1,a2) =
  let mm = matrix_mult pq in
  let mi = matrix_inverse pq in
  (a1, (mi a2) `mm` a1)

-- Token operations:

token_commutator :: Token -> Token -> Token
token_commutator a b =  
  let cmi = (\a -> POW a (-1)) in
    a `MULT` b `MULT` (cmi a) `MULT` (cmi b)

token_and_operation :: (Token,Token) -> (Token,Token) -> IO Token -> IO (Token,Token)
token_and_operation (a1,a2) (b1,b2) sample =
  sample >>= \z -> 
  let cmi = (\a -> POW a (-1)) in
  return (token_commutator (z `MULT` a1 `MULT` (cmi z)) b1,
          token_commutator (z `MULT` a2 `MULT` (cmi z)) b2)

token_not_operation :: (Token,Token) -> (Token,Token)
token_not_operation (a1,a2) =
  let cmi = (\a -> POW a (-1)) in
  (a1, (cmi a2) `MULT` a1)
  
   -----------------------
   -- Lifted operations --
   -----------------------

lift_and :: (Token,Token) -> (Token,Token) -> (Token -> Token) -> IO Token -> IO (Token, Token)
lift_and (a1,a2) (b1,b2) phi sample =
  token_and_operation (phi a1,phi a2) (phi b1,phi b2) sample

lift_not :: (Token,Token) -> (Token -> Token) -> (Token, Token)
lift_not (a1,a2) phi =
  token_not_operation (phi a1,phi a2)
    
   ------------------
   -- Construction --
   ------------------
